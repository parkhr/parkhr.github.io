---
published: true
layout: single
title: "힙"
category:
  - 자료구조
date : 2019-12-05 18:13:00

---

## 힙

**최대 힙**은 각 노드의 키 값이 그 자식의 키값보다 작지 않은 완전 이진 트리이다.

최소 힙은 각 노드의 키 값이 그 자식의 키값보다 크지 않은 완전 이진 트리이다.

<br/>

### 힙의 삽입

원소를 트리의 가장 마지막 부분에 우선 삽입하고, 그의 부모와 비교하여 최대 힙, 최소 힙에 따라 변경한다.

예를 들어 자신의 원소 > 부모의 원소 일 때 둘을 변경한다면 최대 힙, 그 반대는 최소 힙이 된다.

<br/>

### 힙의 삭제

우선순위 큐 이므로 루트를 삭제하고 가장 마지막 원소를 루트에 채운다.

그 후 루트의 자식과 비교하여 변경하는데, 변경될때까지 재귀적으로 검사한다.

<br/>



**구현**

```java
import java.util.Arrays;

public class 힙구현 {
    public static void main(String[] args) {
        int[] arr = new int[7];

        insertHeap(arr, 8);
        insertHeap(arr, 7);
        insertHeap(arr, 11);
        insertHeap(arr, 10);
        insertHeap(arr, 6);
        insertHeap(arr, 3);
        insertHeap(arr, 2);

        System.out.print(deleteHeap(arr) + " ");
        System.out.print(deleteHeap(arr) + " ");
        System.out.print(deleteHeap(arr) + " ");
        System.out.print(deleteHeap(arr) + " ");
        System.out.print(deleteHeap(arr) + " ");
        System.out.print(deleteHeap(arr) + " ");
        System.out.print(deleteHeap(arr) + " ");
    }
  
		// 힙 삭제
    static int deleteHeap(int[] arr){
        int result = arr[0];
        int index = -1;
      
        // 마지막 인덱스 찾기
        boolean check = false;
        for(int i = 0; i < arr.length; i++){
            if(arr[i] == 0){
                index = i - 1;
                check = true;
            }
        }

        if(!check) index = arr.length - 1;
        arr[0] = arr[index];
        arr[index] = 0;

        deleteChange(arr, 0);
        return result;
    }
		
  	// 힙 삭제 시, 변경 작업
    static void deleteChange(int[] arr, int index){
      
      	// 배열 범위를 넘지 않기 위한 기저사례
        if(index * 2 + 1 > arr.length || index * 2 + 2 > arr.length) return ;
      
				// 자식 구하기
        int[] sub = {index*2 + 1, index*2 + 2};

        for (int i = 0; i < sub.length; i++) {
          	// 최대 힙의 조건
            if(arr[index] < arr[sub[i]]){
                int temp = arr[sub[i]];
                arr[sub[i]] = arr[index];
                arr[index] = temp;

                deleteChange(arr, sub[i]);
            }
        }
    }
		
  	// 힙 삽입
    static void insertHeap(int[] arr, int number){
        int index = -1;
        // 넣을 인덱스 찾기
        for(int i = 0; i < arr.length; i++){
            if(arr[i] == 0){
                arr[i] = number;
                index = i;
                break;
            }
        }

        insertChange(arr, index);
    }

    // 힙 삽입 시, 변경 작업
    static void insertChange(int[] arr, int index){
        if(index == 0) return ;

        // 부모 구하기
        int pre = -1;
        if(index % 2 == 0){
            pre = index / 2 -1;
        }
        else pre = index / 2;
				
      	// 최대 힙의 조건
        if(arr[index] > arr[pre]){
            int temp = arr[index];
            arr[index] = arr[pre];
            arr[pre] = temp;

            insertChange(arr, pre);
        }
    }
}

```

