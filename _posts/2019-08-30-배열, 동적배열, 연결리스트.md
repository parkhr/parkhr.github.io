---
published: true
layout: single
title: "자료구조 - 배열, 동적배열, 연결리스트"
category:
  - algorithm
date : 2019-08-30 15:20:00
---

## 배열, 동적배열, 연결리스트

### 배열

```java
int[] arr = new int[5];
```

크기(5)를 지정하여 배열을 생성한다.

크기 이상의 자료를 집어 넣을 수 없다.

<br/>

<br/>

### 동적 배열

크기 이상의 자료를 집어 넣을 수 없는 배열의 단점을 극복하기 위해 나왔다.

자료의 개수가 변함에 따라 크기가 변한다.

<br/>

아래 코드는 삽입 기능만을 구현한 동적 배열이다.

```java
import java.util.Arrays;

public class Main {
	public static void main(String[] args) {
		DynamicArray d = new DynamicArray();
		d.append(1);
		d.append(2);
		d.append(3);
		d.append(4);
		d.append(5);
		System.out.println(d.toString());
	}
}

class DynamicArray{
	int size;
	int capacity;
	int[] array;
	
	DynamicArray() { // 초기화 작업
		this.size = 0; // 현재 배열 위치
		capacity = 5; // 배열 용량
		array = new int[capacity]; // 용량 크기만큼 배열 생성
	}
	
	public void append(int number) {
		if(size + 1 == capacity) { // 만약 현재 배열 위치+1 이 용량과 같다면
			newCreateArray(capacity); // newCreateArray 함수를 호출한다.
			array[++size] = number;
		}else {
			array[++size] = number;
		}
	}
	
	public void newCreateArray(int capacity) {
		this.capacity = capacity * 2; // 현재 용량의 *2 만큼
		int[] newArray = new int[this.capacity]; // 새로운 배열을 생성하고
		arrayCopy(array, newArray); // 새로운 배열에 기존 배열에 있는 값들을 복사후
		
		array = newArray; // 기존 배열의 주소를 새로운 배열 주소로 참조한다.
	}
	
	public void arrayCopy(int[] array, int[] copy) { // 배열 복사
		for(int i = 0; i < array.length; i++) {
			copy[i] = array[i];
		}
	}
	
	public String toString() { // 배열 출력
		return Arrays.toString(array);
	}
}
```

</br>

</br>



### 연결리스트

배열 원소들의 순서를 유지하면서 원소를 삽입하거나, 삭제하는것은 시간이 오래걸린다.

이와 같은 문제점을 해결하기 위해 연결리스트가 생겼다.



아래의 코드는 마지막 위치에 원소를 삽입, 중간 위치에 원소를 삽입하는 연결리스트 코드이다.

난 고수가 아닌 쌩초보이기 때문에 일단 실행이 되는대로만 짜봤다...

```java

public class Main {
	public static void main(String[] args) {
		MyLinkedList list = new MyLinkedList();
		
		list.append(new Node(10));
		list.append(new Node(20));
		list.append(new Node(30));
		
		list.append(5, new Node(40));
		System.out.println(list.toString());
	}
}

class MyLinkedList{
	Node head; // LinkedList의 가장 처음에 위치하는 노드
	
	public void append(Node newNode) {
		if(head == null) head = newNode; // 만약 처음 위치하는 노드가 없을시,
		else {
			Node node = head;
			while(node.nextNode != null) { // 마지막까지 노드를 방문하고
				node = node.nextNode;
			}
			
			node.nextNode = newNode; // 마지막 부분에 삽입
		}
	}
	
	public void append(int index, Node newNode) {
		Node node = head;
		int count = 0;
		
		// index가 0일 때,
		if(index == 0) {
			newNode.nextNode = node;
			this.head = newNode;
			return ;
		}
		
		// index가 0초과 list.size - 1 이하 일때
		while(node.nextNode != null) {
			if(count == index - 1) {
				Node next = node.nextNode;
				node.nextNode = newNode;
				node.nextNode.nextNode = next;
				
				count = 0;
				return ;
			}
			
			node = node.nextNode;
			count++;
		}
		
		// index가 마지막일때
		node.nextNode = newNode;
	}
	
	public String toString() { // list 출력
		Node node = this.head;
		StringBuilder sb = new StringBuilder();
		
		while(node != null) {
			sb.append(node.value).append(" ");
			node = node.nextNode;
		}
		
		return sb.toString();
	}
}

class Node{
	Node nextNode;
	int value;
	
	Node(int value){
		this.nextNode = null;
		this.value = value;
	}
}
```

<br/>

<br/>

### 배열과 리스트의 차이

가장 큰 차이점은 원소의 삽입과 삭제, 접근하는 데 소요되는 시간이다.

삽입과 삭제를 하지 않거나 배열의 끝에서만 수행한다면 배열이 좋은 선택이다.

임의의 원소에 빠르게 접근이 가능하기 때문이다.

만약 임의의 원소를 접근하는게 아닌 모든 원소를 순회하면서 삽입, 삭제를 한다면 연결리스트가 좋다.