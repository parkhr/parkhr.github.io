## 고전적인 동기화 문제

### 생산자 소비자 문제

유한 버퍼에 데이터를 생산하는 생산자와 그 데이터를 소비하는 소비자가 존재한다.

- 생산자
  - 생산자는 아이템 수를 나타내는 count 값이 buffer size와 같다면 여유 공간이 생기기 전까지 while문을 돌며 기다린다.
  - 여유 공간이 생긴 경우 아이템을 생성하며 count를 1 증가 시킨다.
- 소비자
  - 소비자는 buffer에 아무런 데이터가 없다면 while문을 돌며 기다린다.
  - buffer에 데이터가 존재한다면 그 데이터를 소비하여 count를 1감소 시킨다.

이 생산자와 소비자를 병렬적으로 실행할 경우 문제가 발생한다.

예를 들어 count의 값이 5일때 생산자, 소비자 코드가 동시에 실행이 된다면 count는 4, 6 둘다 될수 있다.

<br/>

### Readers - Writers 문제

reader는 공유데이터를 읽기만 하고 writer는 공유데이터를 갱신만 할때, 데이터의 일관성이 무너질 수 있다.

<br/>

### 식사하는 철학자 문제

각각의 철학자가 원형으로 앉아있고 철학자 사이에 젓가락 하나씩 두고 동시에 자신의 왼쪽에 있는 젓가락을 집어드는 경우 Deadlock이 발생한다.

<br/>

## 임계구역

공유 자원에 접근하는 코드의 일부를 말한다.

병렬 프로그래밍에서 만약 하나의 스레드가 공유 데이터의 값을 변경하는 시점에 다른 스레드가 그 값을 읽기를 시도한다면 문제가 발생하게 된다.(데이타의 일관성 등..)

### 임계구역 해결 조건

- 상호 배제 : 하나의 프로세스가 임계 구역에서 실행되고 있다면, 다른 프로세스들은 임계 구역에서 실행 x
- 진행 : 임계 구역에 들어갈 프로세스를 적절히 선택해야 한다.
- 한정된 대기 : 프로세스가 무한으로 대기하는 것을 방지하기 위한 우선순위를 둬야한다.

<br/>

## 교착상태(Dead Lock)

교착상태란 프로세스들이 실행을 끝낼 수 없으며, 다른 작업을 시작하는 것도 불가능한 이도저도 못하는 상황을 말한다.



*교착 상태의 필요 조건*

- 상호 배제
- 점유하며 대기
- 비선점
- 순환대기 : 각 프로세스가 꼬리를 물며 자원을 점유하고 있어야 한다.

<br/>

*교착 상태 처리 방법*

- 예방
- 회피
- 회복
- 무시



