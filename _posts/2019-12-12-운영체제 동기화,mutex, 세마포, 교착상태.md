---
published: true
layout: single
title: "동기화, 뮤텍스, 세마포, 교착상태"
category:
  - operating system
date : 2019-12-12 22:25:00
---

## 고전적인 동기화 문제

### 생산자 소비자 문제

유한 버퍼에 데이터를 생산하는 생산자와 그 데이터를 소비하는 소비자가 존재한다.

- 생산자
  - 생산자는 아이템 수를 나타내는 count 값이 buffer size와 같다면 여유 공간이 생기기 전까지 while문을 돌며 기다린다.
  - 여유 공간이 생긴 경우 아이템을 생성하며 count를 1 증가 시킨다.
- 소비자
  - 소비자는 buffer에 아무런 데이터가 없다면 while문을 돌며 기다린다.
  - buffer에 데이터가 존재한다면 그 데이터를 소비하여 count를 1감소 시킨다.

이 생산자와 소비자를 병렬적으로 실행할 경우 문제가 발생한다.

예를 들어 count의 값이 5일때 생산자, 소비자 코드가 동시에 실행이 된다면 count는 4, 6 둘다 될수 있다.

<br/>

### Readers - Writers 문제

reader는 공유데이터를 읽기만 하고 writer는 공유데이터를 갱신만 할때, 데이터의 일관성이 무너질 수 있다.

<br/>

### 식사하는 철학자 문제

각각의 철학자가 원형으로 앉아있고 철학자 사이에 젓가락 하나씩 두고 동시에 자신의 왼쪽에 있는 젓가락을 집어드는 경우 Deadlock이 발생한다.

<br/><br/>

## Mutex

임계구역 문제를 해결하기 위한 간단한 소프트웨어 도구

```java
do{
	acquire(); // 락이 가용하면 호출 성공 -> 락 사용불가 -> 다른 프로세스들은 락이 반환될 때까지 진입 x
  // 임계구역
  release(); // 락을 반환
  // 나머지구역
}

acquire(){
  while(!available)
    ; // busy wait
  available = false;
}

release(){
  available = true;
}
```

busy wait를 해야하는 단점이 있다. -> CPU의 사이클 낭비

<br/>

<br/>



## 세마포

mutex와 유사하게 동작하지만 좀 더 정교하게 동기화 할 수 있다.

```c
typedef stuct{
  int value;
  struct process *list;
}semaphore;

void wait(semaphore *S){
  S->value--;
  if(S->value < 0){
    // 프로세스를 S->list에 추가한다.
    block(); // 프로세스 중지
  }
}

void signal(semaphore *S){
  S->value++;
  if(S->value <= 0){
    // S->list 로부터 하나의 프로세스 P를 꺼낸다
    wake(P); // 프로세스 실행을 재개
  }
}
```

<br/><br/>

## 임계구역

공유 자원에 접근하는 코드의 일부를 말한다.

병렬 프로그래밍에서 만약 하나의 스레드가 공유 데이터의 값을 변경하는 시점에 다른 스레드가 그 값을 읽기를 시도한다면 문제가 발생하게 된다.(데이타의 일관성 등..)

### 임계구역 해결 조건

- 상호 배제 : 하나의 프로세스가 임계 구역에서 실행되고 있다면, 다른 프로세스들은 임계 구역에서 실행 x
- 진행 : 임계 구역에 들어갈 프로세스를 적절히 선택해야 한다.
- 한정된 대기 : 프로세스가 무한으로 대기하는 것을 방지하기 위한 우선순위를 둬야한다.

<br/>

## 교착상태(Dead Lock)

교착상태란 프로세스들이 실행을 끝낼 수 없으며, 다른 작업을 시작하는 것도 불가능한 이도저도 못하는 상황을 말한다.

<br/>

*교착 상태의 필요 조건*

- 상호 배제 : 최소한 하나의 자원이 한 프로세스만 사용해야한다.
- 점유하며 대기 : 프로세스는 최소한 하나의 자원을 점유한 채, 현재 다른 프로세스에 의해 점유된 자원을 얻기 위해 대기해야 한다.
- 비선점 : 자원이 강제적으로 방출될 수 없고, 점유하고 있는 프로세스가 태스크를 종료한 후 그 프로세스에 의해 자발적으로만 방출될 수 있다.
- 순환대기 : 각 프로세스가 꼬리를 물며 자원을 점유하고 있어야 한다.

<br/>

*교착 상태 처리 방법*

- 예방 : 필요조건들 중 적어도 하나가 성립하지 않도록 보장
- 회피 : 각 프로세스의 미래의 요청과 방출을 고려한다.
- 회복
- 무시