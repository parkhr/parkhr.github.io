---
published: true
layout: single
title: "03.Vue computed"
category:
    - Vue.js
date : 2019-07-01 17:20:00
---


## Vue computed



### computed 속성

```html
<div id="example">
  <p>원본 메시지: "{{ message }}"</p>
  <p>역순으로 표시한 메시지: "{{ reversedMessage }}"</p>
</div>
```

```js

    var vm = new Vue({
      el: '#example',
      data: {
        message: '안녕하세요'
      },
      computed: {
        // 계산된 getter
        reversedMessage: function () {
          // `this` 는 vm 인스턴스를 가리킵니다.
          return this.message.split('').reverse().join('')
        }
      }
    })

```



<br/>

<br/>



우리가 작성한 함수는 vm.reversedMessage 속성에 대한 ***getter 함수***로 사용됩니다.

```js
console.log(vm.reversedMessage) // => '요세하녕안'
vm.message = 'Goodbye'
console.log(vm.reversedMessage) // => 'eybdooG'
```



computed 속성 대신 메소드와 같은 함수를 정의할 수도 있다.

두 가지 접근방식은 최종결과가 서로 동일하지만, computed 속성은 해당 속성이 종속된 대상이 변경될 때만 함수를 실행한다. 즉 `message`가 변경되지 않는 한, computed 속성인 `reversedMessage`를 여러 번 요청해도 계산을 다시 하지 않고 계산되어 있던 결과를 즉시 반환한다.



```js
computed: {
  now: function () {
    return Date.now()
  }
}
```

***Date.now()*** 처럼 아무 곳에도 의존하지 않는 computed 속성의 경우 절대로 업데이트 되지 않는다.



반면 메소드를 호출하면 렌더링을 다시 할 때마다 항상 함수를 실행한다.

computed가 필요한 이유는 계산에 시간이 많이 걸리는 메소드가 항상 실행한다면 꼭 필요한 함수를 실행한 것 보다 많이 실행하게 되기 때문이다.



