---
published: true
layout: single
title: "운영체제 메모리"
category:
  - operating system
date : 2019-12-04 19:20:00
---
## 메모리 관리

### 메모리의 구조

주소(address)와 데이터(data)로 이루어져 있다.

<br/>

<br/>

*프로그램을 메모리에 올리기 과정*

main.c(c언어 파일) -> 컴파일 한다. -> main.o(오브젝트 파일) -> 링커하게되면 내가 작성한 코드가 아닌 라이브러리들을 연결한다.

-> main.exe(실행 파일)

마지막에 생긴 main.exe 파일이 저장장치(HDD)에 저장된다.

이 main.exe 파일을 실행하게 되면 HDD -> 메인메모리로 올라가게 된다.

<br/>

CPU와 메인메모리 사이에는 MMU 라는 것이 있는데, 이는 메모리 주소의 limit와 data를 두어 다른 프로그램이 침범하지 않도록 하는 보호기능과 

CPU의 주소(논리 주소)를 재배치하여 저장장치 주소(물리 주소)로 변경하는 기능이 있다.

<br/>

<br/>

## 연속 메모리 할당

부팅 직후 메모리 상태는 비어있다.

프로세스 생성, 종료를 반복하다보면 scattered holes이 발생하게 된다.

이러한 hole들이 불연속하게 흩어져 있기 때문에 프로세스 적재가 불가능해지는 상황이 온다 => **이를 외부단편화라 한다.**



위의 문제를 해결하기위한 할당 방식이 있다.

- First - fit (최초 적합) : 메모리를 순차적으로 탐색하여 넣을 수 있는 곳이 있다면 넣는 방법
- Best - fit (최적 적합) : size가 제일 비슷한 곳에 넣는 방법
- Worst - fit (최악 적합) : size가 제일 맞지 않는 곳에 넣는 방법

<br/>

<br/>

## 페이징

프로세스를 일정 크기(페이지)로 잘라서 메모리로 적재하는 방법이다.

프로세스는 페이지의 집합, 메모리는 프레임의 집합

각각의 페이지는 각각의 프레임의 들어가야하기 때문에 크기가 같아야 한다.

이때 MMU 내의 재배치 레지스터 값을 변경함으로써 CPU는 프로세스가 연속된 메모리 공간에 위치한다고 착각.

<br/>

## 세그멘테이션

프로세스를 세그먼트의 집합으로 생각한다.

하나의 프로세스가 동작하려면 기본적으로 코드, 데이터, 스택 세 가지의 세그먼트는 항상 가지고 있다.

코드에서도 main 함수가 있을 수 있고, 다른 함수들이 있을 수도 있고, 다른 루틴이 있을 수도 있다. 

데이터를 보아도 어떤 구조체가 있을 수도 있고 배열도 있을 수 있다.

그래서 세그먼테이션은 물리적인 크기의 단위가 아닌 논리적 내용의 단위(의미가 같은)로 자르기 때문에 세그먼트들의 크기는 일반적으로 같지 않다.

<br/>

## 주소 변환

예를 들어, CPU가 13번지를 요구한다.

13의 2진수는 1101

만약 한페이지당 4byte이면 2<sup>2</sup> 이므로 상위 2비트가 페이지 번호이다.

p는 이진수 11 d는 이진수 01

페이지 테이블에 p (= 3) 인 곳을 봤더니 2가 있다면

f는 이진수 10 d는 그대로 01로써 물리주소는  1001(=9번지)이 된다.

<br/>

## 내부단편화

한페이지당 4바이트인데 15바이트 프로세스를 적재하는데 4페이지가 필요하다.

총 16바이트를 필요로하여 1바이트가 남는다. => 이를 내부단편화라 한다.

<br/>



## 가상메모리

물리 메모리 크기의 한계를 극복하기 위해 -> 100MB 메인 메모리에서 200MB 크기의 프로세스를 실행할 수 없다.

**현재 필요한 부분만 메모리에 올려 해결한다** -> **요구페이징(demand paging)**

vaild 비트가 추가된 페이지 테이블을 이용한다. vaild 비트는 페이지 결함인지 아닌지 확인하는 용도.

<br/>

<br/>

## 페이지 결함(Page Fault)

접근하려는 페이지가 메인 메모리에 없다. -> 하드디스크에서 해당 페이지를 가져온다.

<br/>

<br/>

*과정*

cpu가 주소를 낸다. -> valid bit가 0이면 페이지 테이블에서 cpu로 인터럽트를 보내고 -> os 처리 루틴으로 가서 필요로하는 페이지를 메모리에 올린다. -> 올린 부분을 페이지 테이블로 수정후 -> 페이지 사용

<br/>

## 페이지 교체

프로그램 실행에 따라 요구 페이지가 늘어나게되면 -> 언젠가는 메모리가 가득 차게 된다.

메모리가 가득차게 되면 추가로 페이지를 가져오기 위해 어떤 페이지는 backing store로 몰아내고(page out), 그 빈공간으로 페이지를 가져온다 (page in)

어떤 페이지를 몰아낼 것인지에 대한 알고리즘

- FIFO : 메인메모리에 먼저 올라온 페이지를 교체한다.
- OPT : 앞으로 가장 오래 사용안될 페이지를 교체 -> 비현실적
- LRU : 최근에 사용되지 않으면 나중에도 사용된지 않을 것 -> 오래된 페이지를 교체한다.