---
published: true
layout: single
title: "컴퓨터구조 5"
category:
 - 컴퓨터 구조
date : 2019-11-22 20:08:00
---

## 5장 기본 컴퓨터의 구조와 설계

컴퓨터의 구조는 내부 레지스터, 타이밍과 제어구조, 명령어의 집합에 의해서 정의된다.



## 저장 프로그램 구조

Memory 4096 x 16 => 4096워드, 명령어의 크기 16bit

4096워드를 가진 기억 장치는 주소가 4096개 있는 기억장치 이다.

따라서 4096은 2<sup>12</sup> 이므로 주소를 표현하기 위해서는 12비트(0 ~ 4095)가 필요하다.



## 명령어

명령어의 크기 16bit 중 최상위 1bit는 직접/간접 주소 모드, 3bit는 연산코드(opcode), 하위 12bit는 주소를 표현한다.

명령어는 연산코드에 의해 나머지 13bit의 의미가 결정된다.

예를 들어 연산코드가 000이면 AC와 메모리 워드를 AND 연산한다.



## 간접 주소

직접/간접 주소 모드가 0 이면 직접모드 1이면 간접 모드이다.

직접모드는 명령어의 주소부분이 유효주소가 되고, 간접모드는 주소부분을 한번 더 참조하여 유효주소를 찾는다.

예를들어 명령어가 0000 1111 1111 1111 이라면 최상위 비트가 0 이므로 직접 주소 모드이고, 연산코드는 000이므로 AC와 AND연산을 한다.



### 컴퓨터 레지스터

- 데이터 레지스터(DR) : 메모리에서 읽어온 *피연산자*를 저장한다. 16bit
- 누산기 레지스터(AC) : 범용 처리 레지스터 16bit
- 명령어 레지스터(IR) : 메모리에서 읽어온 명령어를 저장한다. 16bit
- 임시 레지스터(TR) : 계산 도중의 임시 데이터를 저장한다. 16bit
- 메모리 주소 레지스터(AR) 12bit
- 프로그램 카운터(PC) : 다음 실행할 명령어 주소를 가리킨다. 12bit
- 입력(INPR) / 출력(OUTR) 레지스터 : 8bit크기의 문자 정보를 송수신한다. 8bit



### 공통 버스 시스템



## 타이밍과 제어

기본 컴퓨터의 모든 플립플롭과 레지스터는 주 클럭 발생기에 의하여 제어된다.

처음 SC(순차 카운터)의 CRL 입력이 1이므로, 첫 번째 클럭의 상승 변이에서 SC 가 0 으로 클리어 되고 이것은 타이밍 순서를 생성한다.

T<sub>0</sub> : AR <- PC
프로그램 카운터가 메모리를 참조할 수 있는 메모리 주소 레지스터로 이동한다.

T<sub>1</sub> : IR <- M[AR], PC = PC+1
AR은 메모리를 참조하여 명령어를 가져와서 IR에 저장하고 프로그램 카운터를 하나 늘려 다음 명령어를 실행시킬 수 있도록 지정한다.

T<sub>2</sub> : D<sub>0</sub> ... , D<sub>7</sub> <- Decode IR(12 - 14) , AR <- IR(0 - 11), I <- IR(15)
연산코드(Opcode) 부분을 디코딩하고, IR의 하위 12비트(주소 부분)을 다시 AR로 넘긴다.
또한 I플립플롭에 IR의 최상위 비트에 넘긴다.

T<sub>3</sub> 동안에 제어장치는 명령어의 종류를 결정한다.
만약 D<sub>7</sub>이 1이면 연산코드가 111이다 -> 그럼 Hexadecimal code 의 시작이 7 이거나, F일 수가 있는데 -> I플립플롭을 검사하여 0 이면 7, 1이면 F로 결정난다.

그럼 T<sub>3</sub> 에서 명령어의 실행이 4가지로 나뉘는데,

- D<sub>7</sub><sup>'</sup> I T<sub>3</sub> : AR <- M[AR] (간접 주소 모드로써 메모리를 다시 참조하는 작업)
- D<sub>7</sub><sup>'</sup> I<sup>'</sup> T<sub>3</sub> : 아무런 일도 하지 않는다.
- D<sub>7 </sub>I<sup>'</sup> T<sub>3</sub> : 레지스터 참조 명령어를 수행한다.
- D<sub>7</sub> I<sup>'</sup> T<sub>3</sub> : 입출력 명령어를 수행한다.

메모리 참조 명령어에서 I = 0 (직접 모드) 인 경우 유효 주소를 읽어올 필요는 없지만(이미 유효주소를 갖기 때문), 실제로 명령어가 수행되는 시간인 T<sub>4</sub> 타이밍 변수를 얻기 위하여 순차 카운터는 증가 동작을 수행한다.



### 레지스터 참조 명령어



## 메모리 참조 명령어(타이밍 변수 : T <sub>4  </sub> 이후 동작)

- AND
  - D<sub>0</sub>T<sub>4</sub> : DR <- M[AR]
  - D<sub>0</sub>T<sub>5</sub> : AC <- AC ^ DR, SC <- 0
  - ALU 연산을 하기 위해 DR 레지스터에 메모리를 참조한 것은 넣고, AND 연산 후 AC에 다시 넣는다.
  - 이후 순차 카운터(SC)를 초기화 해준다.
- ADD
  - D<sub>1</sub>T<sub>4</sub> : DR <- M[AR]
  - D<sub>1</sub>T<sub>5</sub> : AC <- AC + DR, E <- C<sub>out</sub>, SC <- 0
- LDA
  - 유효 주소로 지정된 메모리 워드의 내용을 AC에 전송
  - D<sub>2</sub>T<sub>4</sub> : DR <- M[AR]
  - D<sub>2</sub>T<sub>5</sub> : AC <- DR, SC <- 0
- STA
  - AC의 내용을 유효 주소로 지정된 메모리 워드에 저장한다.
  - D<sub>3</sub>T<sub>4</sub> : M[AR] <- AC, SC <- 0
- BUN
  - 프로그램의 수행을 유효 주소로 지정된 명령어로 옮겨준다.
  - D<sub>4</sub>T<sub>4</sub> : PC <- AR, SC <- 0
- BSA
  - 서브루틴 또는 프로시저라고 하는 프로그램의 일부분으로 분기하는데 사용된다.
  - D<sub>5</sub>T<sub>4</sub> : M[AR] <- PC, AR <- AR + 1
  - D<sub>5</sub>T<sub>5</sub> : PC <- AR, SC <- 0
- ISZ
  - 유효 주소로 지정된 워드의 값을 하나 증가시키고, 증가된 값이 0이면 PC도 하나 증가시켜 다음 명령어를 수행
  - D<sub>6</sub>T<sub>4</sub> : DR <- M[AR]
  - D<sub>6</sub>T<sub>5</sub> : DR <- DR + 1
  - D<sub>6</sub>T<sub>6</sub> : M[AR] <- DR , if (DR = 0 ) then ( PC <- PC + 1), SC <- 0



## 입출력

keyboard -> transmitter interface -> INPR -> AC -> OUTR -> receiver interface -> printer

FGI : 입력 제어 플립플롭

FGO : 출력 제어 플립플롭

<입력 과정>

처음 FGI 가 클리어(0) 되고, 키를 쳤을 때 8비트 코드가 INPR에 시프트 된 후 FGI는 1로 세트된다.

FGI가 1로 세트되어 있는 동안은 다른 키를 쳐서 INPR로 시프트 될 수 없다.

FGI를 체크하여 그것이 1이면 INPR로 부터 AC로 병렬 전송을 하고 FGI를 클리어(0) 시킨다.



<출력 과정>

처음 FGO가 1로 세트되고 컴퓨터는 FGO를 체크하여 1이면 AC로부터 OUTR로 정보를 병렬 전송한다.

그 후 FGO를 클리어(0) 시키면 출력장치는 OUTR로부터 정보를 가져가고 해당되는 문자를 프린트한 후 FGO를 세트(1) 시킨다.

마찬가지로 FGO가 0인 상태에서 컴퓨터는 OUTR에 새로운 정보를 넣을 수 없다.



## 프로그램 인터럽트

입출력 과정과 같이 플래그를 사용한 통신 방법을 프로그램 제어 전송이라고한다.

이것은 프로세서와 입출력 장치와의 속도 차이 때문에 매우 비능률적이다.

인터럽트 인에이블 플립플롭(IEN) 을 통하여 인터럽트를 처리할 수 있다.

IEN이 세트(1)될 때만 인터럽트를 걸 수 있다.